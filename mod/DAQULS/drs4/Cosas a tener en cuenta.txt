La biblioteca "pydrs" fue adaptada y se le agrego la funcion:

---------------------------------------------------------------------------------------------------------------------------------------------------
def get_waveform_all(self) -> dict:
		"""After the board has triggered you can use this method to access
		the data.
		
		Parameters
		----------
		n_channel: int
			Number of channel from which to get the data.
		
		Returns
		-------
		waveform_data: dict
			A dictionary of the form `{'Time (s)': np.array, 'Amplitude (V)': np.array}`
			containing the data.
		"""
		n_channel=1
		# I wrote this function following the example `drs_exam.cpp`.
		ct.check_is_instance(n_channel,'n_channel',int)
		if n_channel not in {1,2,3,4}:
			raise ValueError(f'`n_channel` must be one of 1,2,3 or 4, received {repr(n_channel)}.')
		self.board.get_time(0,n_channel-1,self.board.get_trigger_cell()) # Not sure what this does, but it was in `drs_exam.cpp`.
		return {
			'Amplitude_1 (V)': np.array(self.board.get_waveform_buffer(1-1))*1e-3,
			'Amplitude_2 (V)': np.array(self.board.get_waveform_buffer(2-1))*1e-3,
			'Amplitude_3 (V)': np.array(self.board.get_waveform_buffer(3-1))*1e-3,
			'Amplitude_4 (V)': np.array(self.board.get_waveform_buffer(4-1))*1e-3,
			'Time (s)': np.array(self.board.get_time_buffer(n_channel-1))*1e-9,
		}
---------------------------------------------------------------------------------------------------------------------------------------------------
En donde se toman los cuatros canales del drs4 al mismo tiempo pero me da desconfianza que en verdad no sea al mismo tiempo debido al tiempo inherente 
que puede haber entre comandos en la seccion return{ }
  
Por otro lado se intento usar la funcion 
---------------------------------------------------------------------------------------------------------------------------------------------------
def transfer(self,first=1,last=3):
		n_channel=1
		ct.check_is_instance(n_channel,'n_channel',int)
		if n_channel not in {1,2,3,4}:
			raise ValueError(f'`n_channel` must be one of 1,2,3 or 4, received {repr(n_channel)}.')
		self.board.get_time(0,n_channel-1,self.board.get_trigger_cell()) # Not sure what this does, but it was in `drs_exam.cpp`.
		s=self.board.transfer_waves(0,1)
		return s 
		
---------------------------------------------------------------------------------------------------------------------------------------------------

En donde se uso la funcion "transfer_waves(self, firstChannel: int, lastChannel: int)" la cual se supone llama directamente la funcion 
"DRSBoard::TransferWaves(unsigned char *p, int firstChannel, int lastChannel)" que segun el comentario dentro de esta hace "Transfer all 
waveforms at once from VME or USB to location" dando a entender que entrega la informacion de los cuatro canales del drs4 pero esto solo 
me entrego un numero entero y tambien es importante mencionar que esta ::funcion transferwaves es usada para detener el funcionamiento del
drs4 hasta que reciba una se√±al de un trigger.
  Las funciones usadas por el wrapper original(osea sin este par de funciones agregadas a la biblioteca) estan en "https://github.com/SengerM/pydrs"
  y siendo importante mencionar que en /pydrs/pydrs/cpp y en /pydrs/pydrs/cpp/include estan todas las funciones que usa el drs4 para funcionar.
